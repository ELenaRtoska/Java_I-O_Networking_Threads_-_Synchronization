# Java_IO_Networking_Threads_Synchronization
Java

## Java I/O и Java Networking 
### Задача 1
Да се напише Java програма која ќе прикаже колкава е просечната големина на датотеките со екстензија .txt во именик зададен како аргумент на командна линија.

Напомена: Користете ја File класата за пристап до содржината на именикот.

Решение: Решението од HW01_1.java фајлот го поставувате тука со copy-paste

### Задача 2
Да се напише Java програма која со користење на I/O стримови ќе ја прочита содржината на датотеката izvor.txt, а потоа нејзината содржина ќе ја испише превртена во празната датотека destinacija.txt. Читањето и запишувањето реализирајте го со стримови кои работат бајт по бајт.

Пример:
```
izvor.txt                   destinacija.txt

Оперативни системи          иметсис инвитарепО
```
Напомена: Сами креирајте ги овие две датотеки и пополнете ја izvor.txt со произволна содржина.

### Задача 3
Да се напише Java програма која со користење на I/O стримови ќе ја прочита содржината на датотеката izvor.txt, а потоа нејзината содржина ќе ја испише превртена во празната датотека destinacija.txt. Читањето и запишувањето реализирајте го со баферирано читање и запишување Пример:
```
izvor.txt                   destinacija.txt

Оперативни системи          иметсис инвитарепО
```
Напомена: Сами креирајте ги овие две датотеки и пополнете ја izvor.txt со произволна содржина.

### Задача 4
Некој систем за е-учење генерира извештаи за оценки на студенти по предмети во CSV (Comma Separated Values) формат. Да се напише Java програма, која на екран ќе го отпечати просекот на секој студент од датотеката rezultati.csv (види слика), како и просечната оценка што ја имаат студентите по секој од предметите наведени во првата редица. Програмата треба да работи за произволен број на редици.
```
Студент,КРС,НРС,АОК
11234,8,9,8
13456,6,7,9
11111,7,8,8
10123,10,10,10
```
Бонус: За подобра читливост на извештајот, прочитаната rezultati.csv датотека трансформирајте ја во TSV (Tab Separated Values) формат и снимете ја како rezultati.tsv.

### Задача 5 - Java Networking
Потребно е да се симулира TCP/IP конекција и комуникација меѓу клиент-сервер.

За таа цел, потребно е да креирате две апликации, TCPServer, која ке се извршува на порта 9876 и ќе игра улога на сервер, и TCP Client која ќе се поврзе со серверот и ке му праќа пораки.

Пораките што треба да ги прати TCPClient се следни, и се праќаат во ист редослед како што е дадено:

1.25 (Double) 123584124 (Long) true (boolean) "UTF String" (String)

TCPServer ја очекува истата секвенца на пораки, во ист редослед, и како што ги добива пораките, ги печати на екран.

_Напомена_: Користете соодветни стримови за пишување/читање на примитивни типови

## Java Threads 
### Задача 1
Извршете го примерот од TwoThreads.java. Потоа, модифицирајте ја програмата така што ќе користите само една класа за нитки, ThreadAB. Во конструкторот на класата ќе се предадат двата стринга кои соодветната инстанца треба да ги отпечати. Нитката не треба да ја наследува класата Thread. Однесувањето на новата програма треба да биде исто како на оригиналната, односно повторно треба да имате две нитки кои ќе го извршуваат посебно методот run(): едната нитка ќе печати A и B, додека другата ќе печати 1 и 2.


### Задача 2
Со помош на синхронизациските методи да се реши проблемот за определување на бројот на појавувања на бројот 3 во огромна низа и негово запишување во глобална променлива count.


Секвенцијалното решение не е прифатливо поради тоа што трае многу долго време (поради големината на низата). За таа цел, потребно е да се паралелизира овој процес, при што треба да се напише метода која ќе ги брои појавувањата на бројот 3 во помал фрагмент од низата, при што резултатот повторно се чува во глобалната заедничка променлива count.


### Задача 3
Да се имплементира класа FileScanner која што ќе се однесува како thread. Во класата FileScanner се чуваат податоци за : - патеката на директориумот што треба да се скенира - статичка променлива counter што ќе брои колку нишки од класата FileScanner ќе се креираат Во класата FileScanner да се имплементираа статички методот што ќе печати информации за некоја датотека од следниот формат:

dir: C:\Users\185026\Desktop\lab1 - reshenija 4096 (dir за директориуми, апсолутна патека и големина)

file: C:\Users\Stefan\Desktop\spisok.pdf 29198 (file за обични фајлови, апсолутна патека и големина)

Дополнително да се преоптовари методот run() од класата Thread, така што ќе печати информации за директориумот за којшто е повикан. Доколку во директориумот има други под директориуми, да се креира нова нишка од тип FileScanner што ќе ги прави истите работи како и претходно за фајловите/директориумите што се наоѓаат во тие директориуми (рекурзивно).

На крај да се испечати вредноста на counter-от, односно колку вкупно нишки биле креирани.


### Задача 4
Потребно е да се направи Chat Room апликација, каде повеќе клиенти се поврзуваат на еден сервер преку TCP/IP конекција, и комуницираат меѓусебно.

Серверот, при секое поврзување од клиент креира посебна нишка, која се справува со пораките добиени од соодветниот клиент и препраќање кон бараниот примач. Сите отворени сокети серверот ги чува во HashMap, и кога клиентот ја затвора конекцијата, се остранува и сокетот.

Секој клиент при креирање добива уникатен идентификувачки број, ID, кој се проследува преку конструктор. При иницијализација на клиентот, инцијално параќа почетна порака до серверот со тоа што го проследува соодветниот ID. Клиентот може да испрати порака до друг клиент преку сервверот, со тоа што пораката што ја праќа до серверот е во следен формат:

MESSAGE:RECEIVER_ID

Пример: Клиент со ID 1 праќа порака "Hello from client 1" до клиент со ID 2. Пораката пратена до серверот треба да биде како во прилог:

"Hello from client 1:2"

Серверот, при добивање на порака од клиент, го извлекува ID на примачот од добиената порака, и ја препраќа само пораката до одредениот клиент ( На соодветниот сокет)

Клиентот ја затвара конекцијата до серверот со праќање на пораката "END"


## Threads & Synchronization
### Задача 1
Ве најмуваат од шоуто „Танц со студентите“, да имплементирате софтвер кој автоматски ќе ги контролира портите за насочување на натпреварувачите.

Влезната порта директно води кон една од гардеробите, каде учесниците треба да се пресоблечат. Притоа, во секоја од двете гардероби може паралелно да влезат повеќе учесници од ист пол, но не повеќе од 10.

По пресоблекувањето, учесниците чекаат да дојде произволен партнер, по што излегуваат од соблекувалната и влегуваат во салата за танцување. Во салата паралелно може да танцуваат максимум три пара. По завршувањето на танцот, паровите излегуваат од салата по што може да влезе нов пар на нивно место.

Во почетниот код, дефинирани се класите Masko и Zensko, кои ги симболизираат учесниците од соодветниот пол. Од секој од типовите роботи паралелно се активни повеќе инстанци, кои може да танцуваат само еднаш.

Во имплементацијата, можете да ги користите следните методи од веќе дефинираната променлива show:

show.presobleci()<br />
Го симболизира влегувањето во соблекувалната на учесниците и нивното пресоблекување<br />
Не смее паралелно да биде повикан повеќе од 10 пати од исти пол на учесници<br />
show.tancuvaj()<br />
Го симболизира почетокот на танцот<br />
Се повикува само од машките учесници, бидејќи тие водат при танцувањето<br />
Машкото пред повикот, треба да се осигура дека е присутна учесничка која ќе му биде партнерка<br />
Не смее да има повеќе од три паралелни повици на овој метод<br />
Претходно назначените методи манипулираат со споделен ресурс и ниту еден од нив не е атомичен.

Вашата задача е да ги имплементирате методите Masko.ucestvo() и Zensko.ucestvo() и init(). При имплементацијата, не смеете да додадете try-catch блок во нив. Потребните семафори, глобални променливи и променливи за состојбата на роботите треба да ги дефинирате самите.

Доколку имате грешка, ќе ја добиете пораката:

Procesot ne e sinhroniziran spored uslovite na zadacata

По што ќе ви се прикаже логот на повикување на акциите и настанатите грешки. Овој лог треба да ви послужи за увидување на тоа каде имате грешка во извршувањето на вашата задача.

Напомена: Поради конкурентниот пристап за логирањето, можно е некои од пораките да не се на позицијата каде што треба да се. Токму затоа, овие пораки користете ги само како информација, но не се ослонувајте на нив.

### Задача 2
Потребно е да го синхронизирате сценариото на работа на една берберница. Берберницата има само еден бербер кој спие се додека не се насоберат 5 клиенти. Кога ќе се насоберат 5 клиенти, петтиот го буди берберот и тој започнува да ги потстрижува. Штом берберот ќе ги потстриже сите клиенти што чекаат, тој повторно заспива.

Кога берберот е буден, тој најпрво повикува еден клиент да влезе во берберницата. Кога клиентот ќе биде присутен, започнува процесот на потстрижување. Откако клиентот е потстрижен, тој плаќа и ја напушта берберницата, по што може да влезе нареден клиент. Доколку нема нареден клиент, берберот заспива. Доколку берберот спие, клиентите треба да чекаат додека не се соберат 5 од нив, и петтиот треба да го разбуди берберот.

Во почетниот код кој е даден, дефинирани се класите Barber и Customer, кои ги симболизираат берберот и клиентите. Има само една инстанца од класата Barber кај која методот execute() се повикува онолку пати колку што има клиенти и повеќе инстанци од класата Customer во кои методот execute() се повикува само еднаш.

Вашата задача е да ги имплементирате методите execute() од класата Barber и Customer според претходно опшаното сценарио.

Во имплементацијата, можете да ги користите следните методи од веќе дефинираната променлива state:

state.customerArrived()<br />
Го симболизира пристигнувањето на клиент пред берберницата. Се повикува од клиентот, по неговото пристигнување.<br />
state.barberWakeUp()<br />
Го симболизира будењето на берберот. Се повикува од берберот кога тој се буди.<br />
Доколку берберот е веќе рабуден, повикот ќе фрли исклучок.<br />
state.barberCallCustomer()<br />
Го симболизира повикувањето на клиентот од страна на берберот. Се повикува кај берберот.<br />
Доколку нема пристигнато клиент, овој повик ќе фрли исклучок.<br />
state.customerEntry()<br />
Го симболизира влегувањето на клиентот во берберницата. Се повикува кај клиентот.<br />
Доколку нема пристигнато клиент, или нема повик од берберот, овој повик ќе фрли исклучок.<br />
state.cutHair()<br />
Го симболизира потстрижувањето на клиентот од страна на берберот. Се повикува кај берберот.<br />
Доколку нема присутен клиент во берберницата, овој повик ќе фрли исклучок.<br />
state.customerPay()<br />
Го симболизира плаќањето на клиентот и напуштањето на берберницата. Се повикува кај клиентот.<br />
state.barberGoToSleep()<br />
Го симболизира заспивањето на берберот, кога нема присутни клиенти. Се повикува кај берберот.<br /><br />
Доколку берберот веќе спие или ако има клиенти што чекаат, овој повик ќе фрли исклучок.<br />
Претходно назначените методи служат за проверка на точноста на сценариото и не смеат да бидат променети и мораат да бидат повикани.

Вашата задача е да ги имплементирате методите Barber.execute()и Customer.execute() и init(). При имплементацијата, не смеете да додадете try-catch блок во нив. Потребните семафори, глобални променливи и променливи за состојбите на берберо ти клиентот треба да ги дефинирате самите.

Доколку имате грешка, ќе ја добиете пораката:

Procesot ne e sinhroniziran spored uslovite na zadacata

По што ќе ви се прикаже логот на повикување на акциите и настанатите грешки. Овој лог треба да ви послужи за увидување на тоа каде имате грешка во извршувањето на вашата задача.

Напомена: Поради конкурентниот пристап за логирањето, можно е некои од пораките да не се на позицијата каде што треба да се. Токму затоа, овие пораки користете ги само како информација, но не се ослонувајте на нив.

### Задача 3
Едно племе јаде заеднична вечера од голем котел во кој има ограничен број порции. Секој член од племето сам се послужува, доколку има храна во казанот. Доколку казанот е празен, се повикува готвачот за да зготви нов казан со храна. Притоа, само еден член може да прави провекра на тоа дали има храна во казанот во одреден момент и околу казанот има место за максимум тројца, што значи дека максимум тројца истовремено може да земаат храна, но бројот на членови кои јадат паралелно не е ограничен.

Казанот е иницијално празен.

Вашата задача е да го синхронизирате претходното сценарио.

Во почетниот код кој е даден, дефинирана е класата TribeMember, која го симболизира однесувањето на членовите на племето. Има повеќе инстанци од класата TribeMember кај кои методот execute() се повикува повеќе пати.

Во имплементацијата, можете да ги користите следните методи од веќе дефинираната променлива state:

state.isPotEmpty()<br />
Служи за проверка дали има храна во казанот. Овој метод манипулира со глобални променливи и треба да е во критичен регион.<br />
Доколку повеќе членови паралелно проверуваат, повикот ќе фрли исклучок.<br />
state.fillPlate()<br />
Го симболизира земањето на храна од казанот.<br />
Доколку казанот е празен или повеќе од тројца паралелно земаат храна од казанот, повикот ќе фрли исклучок.<br />
state.eat()<br />
Го симболизира конзумирањето на храната од страна на членовите на племето.<br />
state.cook()<br />
Го симболизира готвењето на храна во казанот од страна на готвачот.<br />
Доколку казанот не е празен, овој повик ќе фрли исклучок.<br />
Претходно назначените методи служат за проверка на точноста на сценариото и не смеат да бидат променети и мораат да бидат повикани.

Вашата задача е да ги имплементирате методите TribeMember.execute() и init(). При имплементацијата, не смеете да додадете try-catch блок во нив. Потребните семафори, глобални променливи и променливи за состојбите на берберо ти клиентот треба да ги дефинирате самите.

Доколку имате грешка, ќе ја добиете пораката:

Procesot ne e sinhroniziran spored uslovite na zadacata

По што ќе ви се прикаже логот на повикување на акциите и настанатите грешки. Овој лог треба да ви послужи за увидување на тоа каде имате грешка во извршувањето на вашата задача.

Напомена: Поради конкурентниот пристап за логирањето, можно е некои од пораките да не се на позицијата каде што треба да се. Токму затоа, овие пораки користете ги само како информација, но не се ослонувајте на нив.

### Задача 4
Да се имплементира мини-систем за гласање. На почетокот, на серверот ги поставуваме сите личности за кои клиентите ќе може да гласааат заедно со нивните броеви (пр. Петар Костадинов – 1, Илија Петковски – 2 итн). Клиентот кога ќе се најави на серверот, треба да го добие цел список за гласање и соодветно да си избере еден од личностите и да гласа, односно гласањето се одвива на тој начин што го одбираме само бројот на дадената личност и го испраќаме на серверот. Кај серверот во секој момент да можеме да провериме колку гласања се остварени и колку бодови има секој од личностите. Серверот да дозволува максимум од 100 клиенти во ист момент.

Забелешка: Да се дефинира протокол на комуникација, т.е. да се дефинира множеството на состојби и форматот на пораките кои ќе се испраќаат.
